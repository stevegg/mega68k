#include "defines.h"
#include "utils.h"

// Memory
byte *RAM;

// Memory map will be that the first 32k is ROM then the next
// 32 is RAM.
byte ROM[] = {
  0x00,0x00,0x80,0x04,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,0x00,0x00,0x01,0x26,
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0x12,0x3c,0x00,0x00,0x4e,0xb9,0x00,0x00,0x01,0x1a,0x10,0x3c,0x00,0x00,0xb0,0x3c,
  0x00,0x05,0x67,0xf0,0x52,0x40,0x4e,0xf8,0x01,0x0e,0x0a,0x01,0x00,0x01,0x13,0xc1,
  0x00,0x00,0xc0,0x00,0x4e,0x75,0x4e,0x73
};

void allocateMemory() {
  Serial.print("Allocating memory....");
  RAM = (byte *)malloc((size_t)RAM_SIZE);
  memset(RAM, 0, (size_t)RAM_SIZE);
  Serial.println("Done");
}

unsigned long getAddress() {
  // We only use the first 5 bits of the X Address.  Last bit is E Signal from 68k
  unsigned long xAddress = ADDRESS_X_PIN & ~((1<<7) | (1<<6) );
  unsigned long hAddress = ADDRESS_HI_PIN;
  unsigned long lAddress = ADDRESS_LOW_PIN;

  // Combine X, H and L into an an address.  Since we don't have an A0 line
  // we'll shift the whole address left by 1 bit to account for this.
  return ((xAddress<<16) | (hAddress<<8) | lAddress) << 1;
}

data_t getDataBus() {
  // Setup Data Bus DDR to INPUT
  DATA_LOW_DDR = B00000000;
#ifdef DATA_BUS_WIDTH_16  
  DATA_HI_DDR = B00000000;
  return ( DATA_HI_PIN << 8 ) | DATA_LOW_PIN;
#else
  return DATA_LOW_PIN;
#endif  
}

void setDataBus(data_t data) {
  // Setup Data Bus DDR to output
  DATA_LOW_DDR = B11111111;
#ifdef DATA_BUS_WIDTH_16  
  DATA_HI_DDR = B11111111;
  DATA_HI_PORT = data >> 8;
  DATA_LOW_PORT = data & 0xFF;
#else
  DATA_LOW_PORT = data;
#endif
}

void setD38(boolean set) {
  if ( set ) {
    PORTD |= (1<<PORTD7);
  } else {
    PORTD &= ~(1<<PORTD7);
  }
}

// MC68000 is Big Endian so we need to return
// a WORD consisting of HI Byte then LO Byte
data_t getROMorRAM(word address) {
  if ( address >= RAM_BASE ) {
#ifdef DATA_BUS_WIDTH_16
    return ( RAM[address - RAM_BASE] << 8 ) | RAM[(address - RAM_BASE) + 1];
#else
    return ( RAM[address - RAM_BASE]);
#endif
  }
#ifdef DATA_BUS_WIDTH_16  
  return ( ROM[address] << 8 ) | ROM [address+1];
#else
  return ( ROM[address] );
#endif  
}

void setRAM(word address, data_t data) {
  Serial.print("Writing ");
  Serial.print(data, 16);
  Serial.print(" to address : ");
  Serial.println(address, 16);
#ifdef DATA_BUS_WIDTH_16  
  RAM[address - RAM_BASE] = data >> 8;
  RAM[(address - RAM_BASE)+1] = data & 0xFF;
#else
  RAM[address - RAM_BASE] = data;
#endif  
}

